연산자 중복 구현 방법
1. 멤버 함수
pt1.operator+(pt2)
2. 전역 함수
operator+(pt1, pt2)

멤버 함수를 사용하는 편이 더 좋음
하지만, 멤버 함수를 쓸 수 없는 경우!
1. 클래스를 사용자가 정의하지 않았을 때,
라이브러리를 사용할 때

이딱다구리들
이딱다구리같은녀석들

함수, 수행을 마치면 자기 자신이 되어야 함
쩝쩝
찝찝
쩝쩝

?
객채[i]
컨테이너[인덱서]
-> 컨테이너 객체
객체 안에 여러 객체

대괄호 연산자
컨테이너 객체에 쓰라고 만듦

븱븱
옷으로 안경 닦는 거 아님

슉슉슉

참조 반환,
간단하게 이름이 반환!

ostrema 객체는 복사될 수 없음!
따라서 참조를 붙임

가지양

입으로 쩝쩝쩝 소리를 내다

X(10)
경우의 수!
1. 함수
2. 함수 포인터
3. 함수 객체(함수자)
function Object
functor 

소괄호 연산자, 함수 객체라고 불림

긁긁딱딱
쩝쩝찝찝

정렬이란
두 원소를 비교에서 앞에 누구를 놓을지 결정
이를 반복적으로 연산!

bool 형식을 반환하는 함수 종류, predicate
무언가 판단하는 역할~

이 딱다구리!

For_each를 때려!

쩝쩝찝찝
와랄라라랄라라

함수는 기능을 수행하지
상태값을 저장하지 않음

어려우면 포기하면 된다.
다시는 C++을 쳐다보지 않는다는 마음가짐~

객체는 상태값을 저장 가능

함수 객체를 사용하는 이유
여러 가지 필요한 상태정보를 통해 유연한 사용 가능!

매게변수로 어떤 타입이 들어올지 몰라~
템플릿, 타입을 받아서
받은 타입에 맞는 함수를 만듦!
함수의 틀~

더불형
더불어 살자

보통은 목적이 정해짐!
int를 가져와야 겠다~

목적이 정해지지 않은 친구들
-> 알고리즘, 문제를 해결하는 절차
Ex. Swap, 교환하기 위한 절차

모든 함수가 템플릿일 필요는 없다!
필요한 함수만

다음 시간
클래스 템플릿
자료구조(객체),
컨테이너(객체)

어떤 타입을 가진 스택?
클라이언트가 결정

다만, 만드는 일이 드물다.
대부분은 함수 템플릿을 만듦

함수 객체
가벼운 친구!
참조를 붙이지 않는다~

객체는 괄호를 붙여야만 함!

