CPlusProgramming_240522

오늘 공부하는 내용!
상속과 다형성의 핵심~
중요하다~~

스택에 객체를 만들 수 있는 언어, C++!

이름은 내가 초기화 할 수 없다
물려받았기 때문에, 초기화 책임도 부모가 가짐

오버라이드
부모의 메소드를 그대로 사용할 수 없다
재정의가 필요!

자식 객체는 부모 객체 타입이다
1. shape s = r; c;
2. shape& s = r; c;
3. shape* ps = &r; &c;
C++, 셋 다 가능
다른 언어는 3번 방법만 가능

쩝쩝
찝찝

근데...
 C++, 1번 사용하지 않는다
메모리가 잘려나가는 문제 발생
슬라이스~

참조는 지정하기만 하는거라
메모리 문제는 발생하지 않음

자바는 가상메소드만!
일반 함수는 컴파인바인드?
호출 속도가 더 빠름

재정의 메소드는 가상 메소드로 만들어야 함
(현재 지식 수준)

일반 함수에서 재정의 메소드를 만들면
올바른 동작을 할 수 없음!

티라노 이동해!!
똑같은 티라노에게
공룡 이동해!! -> 티라노처럼 이동해야 함
하지만 공룡처럼 이동하는 사태 발생!!

다형성
유사한 타입에 대한 메소드에
서로다른 반응!!

다형성을 지원하는 방법
1. 계층 구조
2. 가상 메소드
3. 메소드 재정의(오버라이딩)

대부분의 객체는 Heap 영역에

앵간하면 객체 만들 때 
구체적인 유형 지정하지 않음
단, new 지정 시 구체적으로!
Shape* s = new Rect(0, 0, 100, 200, "rect");

명령을 때리다

delete 2가지 기능
1. 메모리 제거
2. 소멸자 호출

부모 소멸자가 호출되는 이유는 정적바인딩
정적바인딩 대신 동적바인딩을 하도록

const, 객체의 상태
객체의 상태를 변경하지 않기 위한 키워드
30~40% 틀림

부모 클래스로 만들어지는 순간!!
소멸자는 반드시 가상으로!!!

사유(이해해도그만안해도그만)
컴파일시점
코드를 해석하는 시점에
소멸자를 결정
S가 어떤 객체를 할 지 몰라~~ 

근데 객체는 실행시점에 만들어짐!

바인딩!
2개를 연결한다.
객체지향에서는 객체와 함수를 연결하는 작업을 의미

객체는 실직적으로 메소드를 가지지 않음
논리적으로만
이 연결고리가 this!

가상 소멸자
부모 클래스로 정의 하면 사용
자식이 어떤 마무리 작업을 할지 몰라!!

객체를 만드는 클래스
객체를 만들지 않는 클래스
부모는 자식의 공통된 개념을 표현
유닛을 만들다 =
실제 객체를 만들기 위한 표현이 아님

실제 객체를 만드는 클래스, concrete 구체화
개념만 만드는 클래스, abstrect 

이 딱다구리!

순수 가상 함수를 하나라도 가지고 있으면
해당 클래스는 객체를 만들 수 없음!

컨트롤 씨
랄랄랄랄라~

에이컨 추우면 알아서 꺼도 괜찮!

객체 같이 엮고 싶다~~
부모 클래스가 있어야 함

스타크래프는 99퍼 C++!!

순수가상메소드(추상메소드)
자식이 나를 재정의 하기를 강제화!
추상메소드를 가지고 있으면 추상 클래스





















